% \iffalse meta-comment
%
% This file is part of the package redrum for use with LaTeX2e.
%
% Function: Access to 150 paragraphs of the well known "All work and
% no play" dummy text, as featured in Stanley Kubrick's movie "The Shining".
%
% This program may be distributed and/or modified under the
% conditions of the LaTeX Project Public License, either version 1.3
% of this license or (at your option) any later version.
% The latest version of this license is in
%   http://www.latex-project.org/lppl.txt
% and version 1.3 or later is part of all distributions of LaTeX
% version 2005/12/01 or later.
%
% Please send error reports and suggestions for improvements to
%    https://github.com/GComitini/redrum
%
\def\redrumversion{1.0}
\def\redrumdate{2024-10-31}
%<*driver>
\ProvidesFile{redrum.dtx}%
  [\redrumdate\space v\redrumversion\space
   Access to 150 of All work and no play dummy text]
\documentclass{l3doc}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{enumitem}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usepackage[a4paper,
  top=2cm, left=8.8cm, right=2cm, bottom=3cm,
  marginparwidth=6.3cm, marginparsep=.5cm,
]{geometry}
\newlength\fullmargin
\setlength\fullmargin\marginparwidth
\addtolength\fullmargin\marginparsep
\usepackage{mdframed}
\mdfdefinestyle{expl}{%
  backgroundcolor=black!5!white,
  linewidth=0pt,
  middlelinewidth=0pt
}
\newmdenv[style=expl]{explbox}

\usepackage{redrum,multicol}
\usepackage{multirow}
\usepackage[latin, english]{babel}
\makeatletter
\newcommand\@subtitle{}
\newcommand\subtitle[1]{%
  \renewcommand\@subtitle{#1}}
  \renewcommand\maketitle[1]{%
  \noindent
  \hspace{-\fullmargin}%
  \begin{minipage}{\textwidth+\fullmargin}
    \renewcommand\thefootnote{\fnsymbol{footnote}}
    \let\thanks\footnote
    {
      \centering
      {\LARGE \@title}\\[.8\baselineskip]
      {\LARGE \@subtitle}\\[2\baselineskip]
      {\Large \@author}\\[\baselineskip]
      {\Large \@date}\\[\baselineskip]
    }
    \ifx\\#1\\\else
      \begin{multicols}{2}[%
        \subsection*{\hfill\abstractname\hfill\null}]
        \setlength{\columnsep}{.5cm}%
        #1
      \end{multicols}
    \fi
  \end{minipage}}
\makeatother
\newenvironment{wide}
  {\hspace{-.75\fullmargin}%
   \begin{minipage}{\textwidth+.75\fullmargin}}
  {\end{minipage}}
\newcommand\opt[1]{\textsf{#1}} % l3doc does not have some markup for package options...
\newcommand\redr{\emph{All work and no play\ldots}}
\renewcommand\topfraction{.85}
\renewcommand\textfraction{.15}
\renewcommand\floatpagefraction{.85}
\emergencystretch 2em
\newcommand\secref[1]{(see section~\ref{#1})}
\usepackage{hyperref}
\def\ghissue#1{%
  \texttt{\##1}\footnote{%
    \url{https://github.com/GComitini/redrum/issues/#1}}}
\begin{document}
  \DocInput{redrum.dtx}
\end{document}
%</driver>
%<*package>
\NeedsTeXFormat{LaTeX2e}
\RequirePackage{l3keys2e}
\@ifundefined{NewDocumentCommand}
  {\RequirePackage{xparse}}{}
\ProvidesExplPackage {redrum} {\redrumdate} {\redrumversion}
  {150 paragraphs of ``All work and no play'' dummy text from Stanley Kubrick's movie ``The Shining''}
%</package>
% \fi
%
% \title{\pkg{redrum}}
% \subtitle{Access to 150 paragraphs of ``All work and no play'' dummy
% text from Stanley Kubrick's movie ``The Shining''\thanks{Version: \redrumversion.}^^A
% \thanks{This is a fork of \pkg{lipsum}, written by Patrick Happel
%  (\href{mailto:patrick.happel@rub.de}{patrick.happel\meta{at}rub.de})
%  and maintained by Phelype Oleinik (\href{mailto:phelype.oleinik@latex-project.org}
%  {phelype.oleinik\meta{at}latex-project.org}).}}
% \author{Giorgio Comitini\thanks{Original docs authors: Patrick Happel
%  (\href{mailto:patrick.happel@rub.de}{patrick.happel\meta{at}rub.de}) and
%  Phelype Oleinik (\href{mailto:phelype.oleinik@latex-project.org}
%  {phelype.oleinik\meta{at}latex-project.org}).}}
% \date{\today}
% \RecordChanges
% \changes{v1.0}{2024/10/31}{Forked \pkg{redrum} from \pkg{lipsum}}
%
% \maketitle{\pkg{redrum} is a \LaTeX{} package that produces dummy text
% to be used in test documents or examples. The paragraphs are taken from
% Stanley Kubrick's movie \emph{The Shining}. The package itself is meant
% to make you have a good laugh while still being useful for your very
% serious -- and at times quite stressful -- work. Let's face it, we all
% kinda understand what Jack Torrance was going through when writing that
% abstract or those conclusions that just don't seem to materialize on
% paper.
%
% Please, file bug reports, typos in the documentation or feature requests
% as an issue on \url{https://github.com/GComitini/redrum/issues}. If you
% would like to see more fun texts in \pkg{redrum} don't hesitate to
% propose them!}
%
% \begin{documentation}
%
% \section{Introduction}
%
% To load the package, write
% \begin{verbatim}
%     \usepackage{redrum}
% \end{verbatim}
% in the preamble of your document. Probably the most important macro
% provided by this package is \DescribeMacro{\redrum}\cs{redrum}, which
% typesets the \emph{All work and no play} paragraphs. The first optional
% argument allows to specify the range of the paragraphs. For example,
% \verb|\redrum[4-57]| typesets the paragraphs 4 to 57 and accordingly,
% \verb|\redrum[23]| typesets the 23\textsuperscript{rd} paragraph\footnote{
% The paragraphs of the \emph{All work and no play} text have a variable
% number of same-sentences so as to still be useful as dummy text.}.
% Using \cs{redrum} without its optional argument typesets the
% paragraphs 1--7 of \redr
%
% \cs{redrum} has a second optional argument which allows selecting a range
% of sentences from the paragraphs. To get the sentences four to eight from
% paragraphs three to nine, use |\redrum[3-9][4-8]|. The sentences are counted
% from the first sentence of the first selected paragraph.  In the previous
% example, sentence number~1 is the first sentence of paragraph number~3.
%
% \subsection{Foreword to Version 1.0}
% \label{sec:foreword2.7}
%
% \pkg{redrum} was forked from \pkg{lipsum} at version~2.7. It replaced the
% old latin-like texts with the well-known \emph{All work and no play} and
% set it as the default dummy text provided by the package.
%
% Please note that the documentation only refers to the \emph{All work and no play}
% text, even if \pkg{redrum} also supports other texts.
%
% \section{Usage}
%
% \pkg{redrum} was intended to quickly provide a way to fill a page or two to
% analyze the page
% layout\footnote{\url{https://groups.google.com/d/topic/de.comp.text.tex/oPeLOjkrLfk}}
% while humorously citing Stanley Kubrick's ``The Shining''. While it provides some
% more advanced features, it still is only intended to quickly provide text. If you
% want more serious dummy text, look at the \pkg{lipsum} package. If you want more
% features, look at the \pkg{blindtext} package.
%
% \subsection{Package Options}
% \label{sec:pkg-opt}
%
% \pkg{redrum} outputs a range of paragraphs taken from the \redr\ dummy
% text. The package options control mainly the behaviour of the
% \cs{redrum} and \cs{unpackredrum} commands, and can be set at
% load-time with \cs{usepackage}|[|\meta{option}|]{redrum}|, or later in
% the document by using \cs{setredrum}|{|\meta{option}|}|.
%
% \begingroup
%   \RenewDocumentCommand \item { r[] e= d() }
%     {\par\medskip\noindent\llap
%       {\smash{\begin{tabular}{@{}l@{}}\toprule
%         \opt{#1}\\\bottomrule\end{tabular}}~~}%^^A
%      \IfValueT{#2}{=~~\!\meta{#2}\hfill
%        \IfValueT{#3}{\quad(default: \texttt{#3})}\null
%        \newline}\ignorespaces}
%
% \item[nopar]={boolean}(false)
%   Changes the initial default separator between each paragraph of
%   \cs{redrum} from \cs{par} to \cs{space}, and the other way around
%   for \cs{redrum*}.
% \item[text]={name}(redrum)
%   Selects the dummy text \meta{name} that is used by \cs{redrum} and
%   \cs{unpackredrum}. At this time, only the ``All work and no play''
%   text is provided \secref{sec:other-texts}.
% \item[language]={lang}(latin)
%   Sets the language to be used by \cs{redrum} to typeset the currently
%   active dummy text \secref{sec:hyphenation}.
% \item[auto-lang]={boolean}(true)
%   Turns on/off automatic language switching. See
%   section~\ref{sec:hyphenation} for more details.
% \item[default-range]={p_i\texttt{-}p_f}(1-7)
%   Sets the default range of paragraphs produced by \cs{redrum} when no
%   optional argument is provided.  The value to \opt{default-range}
%   obeys the \meta{range} syntax described in
%   section~\ref{sec:range-syntax}.  If no value is given to
%   \opt{default-range} (that is, \cs{setredrum}|{default-range}|), then
%   the default is reset to |1-7|.
%
% \endgroup
%
% \medskip
%
% Besides these options, there are still ones that can be passed to the
% package to influence the paragraph and sentence separators and other
% such things.  These options are detailed in
% section~\ref{sec:separators}.
%
%^^A Besides the listed options, there are still options that can be
%^^A passed to the package to influence the paragraph and sentence
%^^A separators and other things like that.  The options for paragraphs
%^^A are:
%^^A \AddToHookNext{env/multicols/before}
%^^A   {\setlength{\multicolsep}{0.5\multicolsep}}
%^^A \begin{multicols}{2}
%^^A   \ttfamily \setlist{nosep}
%^^A   \begin{itemize}
%^^A     \item par-before
%^^A     \item par-begin
%^^A     \item par-sep
%^^A     \item par-end
%^^A     \item par-after
%^^A   \end{itemize}
%^^A   \begin{itemize}
%^^A     \item par-before*
%^^A     \item par-begin*
%^^A     \item par-sep*
%^^A     \item par-end*
%^^A     \item par-after*
%^^A   \end{itemize}
%^^A \end{multicols}
%^^A and for sentences, the same group with |sentence| instead of |par|
%^^A in their name.  These options are detailed in
%^^A section~\ref{sec:separators}.
%
% \subsection{User Commands}
%
% \begin{function}{\redrum}
%   \begin{syntax}
%     \cs{redrum}\meta{*}\oarg{par range}\oarg{sentence range}
%   \end{syntax}
%   \cs{redrum} outputs the \meta{par range} from the
%   currently active dummy text.  If \meta{par range} is not given
%   or is empty, the \opt{default-range} (initially |1-7|) is output.
%   ^^A
%   If a \meta{sentence range} is given, the selected paragraphs are
%   split into sentences, numbered starting from~1, and the specified
%   range of sentences is taken out from those paragraphs.
%   ^^A
%   If the \meta{*} version is used, a different set of separators is
%   inserted around the paragraphs or sentences.
%
%   \cs{redrum} changes the active language to that of the dummy text
%   for typesetting, so the proper hyphenation patterns are used.
%   See section~\ref{sec:hyphenation}.
%   ^^A
%   Section~\ref{sec:range-syntax} explains the syntax of ranges, and
%   section~\ref{sec:separators} explains the separators added around
%   the pieces of text.
% \end{function}
%
% \begin{function}{\unpackredrum,\redrumexp}
%   \begin{syntax}
%     \cs{unpackredrum}\meta{*}\oarg{par range}\oarg{sentence range}
%     \ldots
%     \cs{redrumexp}
%   \end{syntax}
%   \cs{unpackredrum} selects the paragraphs and/or sentences exactly as
%   described for \cs{redrum}, but instead of outputting them, it saves
%   the selected text in the \cs{redrumexp} macro. Additionally,
%   \cs{unpackredrum} \ldots\cs{redrumexp} is not completely equivalent
%   to \cs{redrum} because it doesn't change languages as \cs{redrum}
%   does.
% \end{function}
%
% \begin{function}{\setredrum}
%   \begin{syntax}
%     \cs{setredrum}\Arg{key-val list}
%   \end{syntax}
%   Applies the \meta{key-val list} of options to the package.  The
%   options are described in section~\ref{sec:pkg-opt} and in
%   section~\ref{sec:separators}.
% \end{function}
%
% \subsection{Other commands}
%
% These commands exist for necessity or backwards compatibility, and
% should normally not be needed in user documents.
%
% \begin{function}{\SetRedrumText}
%   \begin{syntax}
%     \cs{SetRedrumText}\Arg{name}
%   \end{syntax}
%   Loads the dummy text \meta{name} \secref{sec:other-texts}.
%   This command does the same as option \opt{text}, but it is
%   kept for backwards compatibility.
% \end{function}
%
% \begin{function}{\SetRedrumDefault}
%   \begin{syntax}
%     \cs{SetRedrumDefault}\Arg{range}
%   \end{syntax}
%   Sets the default range for \cs{redrum} and \cs{unpackredrum}.
%   This command does the same as option \opt{default-range}, but it is
%   kept for backwards compatibility.
% \end{function}
%
% \section{General remarks on behaviour}
%
% Here are some topics that are general considerations about the
% behaviour of \pkg{redrum} and its commands.  These are technicalities
% that most end users don't care too much about, unless you are trying
% to do something beyond the usual ``print me some dummy text''.
%
% \subsection{Syntax of paragraph and sentence ranges}
% \label{sec:range-syntax}
%
% A \meta{range} argument can either be blank, a single integer, or a
% proper integer range.  If the \meta{range} argument is blank, the
% commands behave as if the argument was not given at all.  For example,
% |\redrum[]| behaves exaclty like |\redrum| and outputs the default
% paragraph range.  Note that |\redrum[][2-5]| does \textbf{not} behave
% as |\redrum[2-5]|, but behaves as |\redrum[1-7][2-5]| (assuming
% |default=range=1-7|), because the default value is then taken for the
% first argument.  If the \meta{range} argument is an integer, then only
% a single paragraph/sentence is selected.
%
% If the argument contains a |-| (\textsc{ascii}~45), it is interpreted
% as a \emph{proper} range \meta{n_i}|-|\meta{n_f}.  In a proper range,
% if \meta{n_i} is blank, it is taken to be the start of the possible
% range, and in the same way, if \meta{n_f} is empty it is taken to be
% the end of the possible range.  That is, |\redrum[-9]| is the same as
% |\redrum[1-9]|, and |\redrum[5-]| is the same (assuming the standard
% 150-paragraph dummy text) as |\redrum[5-150]|, and similarly,
% |\redrum[-]| is the same as |\redrum[1-150]|.
%
% Only one |-| is allowed in a range, so if more than one |-| is given,
% an error is raised and no paragraphs/sentences are output.  No
% paragraphs or sentences will be output also in case one of the ranges
% is reversed, so |\redrum[2-1]| returns no paragraphs, as does
% |\redrum[][2-1]| output no sentences, for example.  Note that
% ``returning no paragraphs/sentences'' is not ``the output is empty'':
% that is mostly true, except that the |-before| and |-after| separators
% are still output \secref{sec:separators}.
%
% Finally, if a range spans more paragraphs or sentences than what the
% dummy text actually provides, the range is truncated so that it fits
% the available text.  If the range in the argument does not intersect
% with the range provided by the dummy text, no paragraphs or sentences
% are output.
%
% \subsection{Hyphenation patterns}
% \label{sec:hyphenation}
%
% The command \cs{redrum} automatically changes the hyphenation patterns
% when typesetting a dummy text, so that line-breaking looks better.
% This feature is on by default, so if you don't want it you have to
% explicitly disable automatic language switching with
% |\setredrum{auto-lang=false}|.
%
% The language is defined individually for each dummy text
% \secref{sec:other-texts}, but you may change it for the current dummy
% text by using |\setredrum{language=|\meta{lang}|}|.  If you load
% another dummy text (for example with the \opt{text} option), then the
% option \opt{language} is also changed according to the dummy text
% loaded \secref{sec:other-texts}.
%
% \subsection{Paragraph and sentence separators}
% \label{sec:separators}
%
% As may be clear by now, \pkg{redrum} has two modes of operation:
% sentence output, and paragraph output, selected by providing or not
% providing the second optional argument to \cs{redrum}.  In each mode,
% the dummy text is separated into chunks (paragraphs or sentences),
% which are counted, and then output accordingly.
%
% When \cs{redrum} (or \cs{unpackredrum}) is used with a single (or no)
% optional argument, then a range of paragraphs is output, along with
% some ``separators'' (in the lack of a better name) between paragraphs,
% around each paragraph, and before and after the whole output.
% A schematic (very colorful) representation of the output is:
%
% \begin{function}{
%     par-before,
%     par-begin,
%     par-sep,
%     par-end,
%     par-after,
%     sentence-before,
%     sentence-begin,
%     sentence-sep,
%     sentence-end,
%     sentence-after,
%   }
% \noindent
% \begin{tikzpicture}[x=0.703cm,
%     item/.style={
%       draw,
%       rounded corners=2mm,
%       minimum width=2.2cm,
%       execute at begin node=\strut,
%       rotate=54,
%       font=\footnotesize,
%     },
%   ]
%   \def\sep#1{\texttt{par-\textbf{#1}}\null}
%   \node [item,fill=red!40  ] at (0 ,0) {\sep{before}};
%   \node [item,fill=red!20  ] at (1 ,0) {\sep{begin }};
%   \node [item,fill=red!20  ] at (2 ,0) {\meta{paragraph}};
%   \node [item,fill=red!20  ] at (3 ,0) {\sep{end \  }};
%   \node [item,shading=axis,left color=red!30,right color=green!30,
%            shading angle=54] at (4 ,0) {\sep{sep \  }};
%   \node [item,fill=green!20] at (5 ,0) {\sep{begin }};
%   \node [item,fill=green!20] at (6 ,0) {\meta{paragraph}};
%   \node [item,fill=green!20] at (7 ,0) {\sep{end \  }};
%   \node [item,shading=axis,left color=green!30,right color=blue!30,
%            shading angle=54] at (8 ,0) {\sep{sep \  }};
%   \node [item,fill=blue!20 ] at (9 ,0) {\sep{begin }};
%   \node [item,fill=blue!20 ] at (10,0) {\meta{paragraph}};
%   \node [item,fill=blue!20 ] at (11,0) {\sep{end \  }};
%   \node [item,fill=blue!40 ] at (12,0) {\sep{after\ }};
% \end{tikzpicture}
%
% When \cs{redrum} is called, the first thing it outputs is the
% \opt{par-before} tokens.  These tokens are output unconditionally,
% regardless of how many (if any) paragraph is output.
%
% Then, before each paragraph in the range, \cs{redrum} outputs the
% \opt{par-begin} tokens, and then the actual text of the
% \meta{paragraph}, and then the \opt{par-end} tokens.  These tokens are
% output conditionally, if the paragraph text is output.  If more than
% one paragraph is output, then the \opt{par-sep} tokens are inserted
% between the \opt{par-end} of one paragraph and the \opt{par-begin} of
% the paragraph that follows.
%
% \end{function}
%
% Finally, at the end, the \opt{par-after} tokens are inserted
% unconditionally at the end, same as for \opt{par-before}.
%
% As mentioned before, in case of an error parsing the range, the output
% will be no paragraphs, but the \opt{par-before} and \opt{par-after}
% tokens are still output.
%
% The explanation above is equally valid for the starred variants.  If
% \cs{redrum}|*| is used, the \opt{par-before*} tokens are
% inserted, and so on.  It is also true for sentences (starred or
% otherwise), replacing |par| in the option names by |sentence|, so when
% you use, for example, |\redrum[][1-9]|, the \opt{sentence-before}
% tokens will be unconditionally inserted, and so on.
%
% Note that, when \cs{redrum} is used in sentence-mode (for example,
% with |\redrum[1-3][1-9]|), only the |sentence-...| tokens are inserted
% in the output, regardless of how many paragraphs those sentences were
% collected from. In the same way, if paragraph-mode is being used, only
% |par-...| tokens are inserted.
%
% \section{Loading and defining dummy texts}
% \label{sec:other-texts}
%
% A simple interface is provided to define and load other texts for the
% output of \cs{redrum} and friends. This interface can, for example,
% be used to implement dummy texts in different languages without
% re-coding the logic implemented by \pkg{redrum}.
%
% \begin{function}{\NewRedrumPar}
%   \begin{syntax}
%     \cs{NewRedrumPar}\Arg{paragraph}
%   \end{syntax}
%   In order to provide a new text that will be used by \pkg{redrum},
%   define the text by using a set of \cs{NewRedrumPar}\Arg{paragraph}
%   commands in a file with the ending |.ltd.tex| (|ltd| means
%   \emph{lipsum text definition}\footnotemark{}) to a location where
%   your \TeX{} system will find it. The \meta{paragraph}-argument is a
%   single paragraph of the new text. Thus, the first occurence of
%   \cs{NewRedrumPar} defines the first paragraph, the second occurence
%   the second paragraph and so on.
% \end{function}
% \footnotetext{To avoid name clashes with files using general languages
% as names, the \pkg{lipsum} authors chose to introduce the |.ltd.tex|
% file ending.}
%
% \begin{function}{\SetRedrumLanguage}
%   \begin{syntax}
%     \cs{SetRedrumLanguage}\Arg{lang}
%   \end{syntax}
%   Additionally, tell \pkg{redrum} the language of the dummy text using
%   \cs{SetRedrumLanguage}\Arg{lang} somewhere in the |.ltd.tex| file.
% \end{function}
%
% \medskip
%
% To specify the new text as output for \cs{redrum} and friends, use
% \cs{setredrum}|{|\opt{text}|=|\meta{name}|}|, where \meta{name} is the
% name of the file without the ending |.ltd.tex|, as given in the table
% below.  When a new dummy text is loaded, the previous one is cleared,
% and the language is changed as well, according to the table.
%
% \begin{table}[ht]
% \begin{wide}
% \begin{tabularx}{\textwidth}{lllX}
%   \toprule
%     File (\texttt{.ltd.tex}) & Language & Source & Description \\
%   \midrule
%     \texttt{redrum} & Latin
%       & Stanley Kubrick's ``The Shining''
%         & Contains the \emph{All work and no play} dummy text, as
%           featured in the movie \emph{The Shining} (default). \\
%   \bottomrule
% \end{tabularx}
% \end{wide}
% \end{table}
%
% \subsection{Guidelines on providing new dummy texts}
%
% \cs{SetRedrumText} more or less just uses an \cs{input} or, to be more
% precise, the \LaTeX3-variant \cs{file_input:n}, to load the |.ltd.tex|
% file. This means, that the file is not necessarily loaded in the
% preamble of the document and thus the contents of the file underlie
% the respective restrictions.
%
% Should you want a new dummy text, \textbf{especially if humorous and
% thus not so suitable for inclusion in \pkg{lipsum}}, create an issue
% in the GitHub repository\footnote{\url{https://github.com/GComitini/redrum}}
% with the source for the dummy text.
%
% Should you prefer to distribute the dummy text as a separate package,
% make sure that the text follows the layout of \pkg{redrum}'s dummy
% texts, so that everything works correctly.  The dummy text definition
% file should contain a line with \cs{SetRedrumLanguage}, and then as
% many \cs{NewRedrumPar} entries as there are paragraphs in the dummy
% text.  Make sure that the file has the |.ltd.tex| extension, and
% everything should work smoothly.
%
% \end{documentation}
%
% \clearpage
% \newgeometry{left=5cm,right=2cm}
%
% \begin{implementation}
%
% \section{\pkg{redrum} Implementation}
%
%    \begin{macrocode}
%<*package>
%<@@=redrum>
%    \end{macrocode}
%
% \subsection{Variables}
%
% \begin{variable}{\g_@@_par_int}
%   Stores the number of paragraphs in the current text.
%    \begin{macrocode}
\int_new:N \g_@@_par_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_language_tl}
%   Stores the language of the dummy text for hyphenation patterns.
%    \begin{macrocode}
\tl_new:N \g_@@_language_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\g_redrum_default_range_tl}
%   The default range for redrum paragraphs.
%    \begin{macrocode}
\tl_new:N \g_redrum_default_range_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_output_tl}
%   This variables is used to store the token list containing the
%   selected output.
%    \begin{macrocode}
\tl_new:N \l_@@_output_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_@@_text_str}
%   Holds the current text loaded for the output of \cs{redrum} and
%   friends. Used to avoid loading the same text definition if it is
%   already used.
%    \begin{macrocode}
\str_new:N \g_@@_text_str
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_sep_set_str}
%   Holds the name of the active separator token set.  By default it is
%   empty to use the default separator set (empty).
%    \begin{macrocode}
\str_new:N \l_@@_sep_set_str
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_autolang_bool}
%   Boolean whether to change hyphenation patterns according to the
%   dummy text language.
%    \begin{macrocode}
\bool_new:N \l_@@_autolang_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\q_@@_mark,\s_@@}
%   Quark and scan mark used throughout the package.
%    \begin{macrocode}
\quark_new:N \q_@@_mark
\scan_new:N \s_@@
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_tmpa_str,\l_@@_a_int,\l_@@_b_int}
%   Scratch variables.
%    \begin{macrocode}
\str_new:N \l_@@_tmpa_str
\int_new:N \l_@@_a_int
\int_new:N \l_@@_b_int
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\@@_tmp:w}
%   Scratch macro.
%    \begin{macrocode}
\cs_new_eq:NN \@@_tmp:w ?
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_<thing>_<place>_<version>_tl}
%   \csname @gobble\endcsname{
%     \l_@@_par_end_nostar_tl,
%     \l_@@_par_end_star_tl,
%     \l_@@_par_end__tl,
%     \l_@@_par_itemend_nostar_tl,
%     \l_@@_par_itemend_star_tl,
%     \l_@@_par_itemend__tl,
%     \l_@@_par_itemseparator_nostar_tl,
%     \l_@@_par_itemseparator_star_tl,
%     \l_@@_par_itemseparator__tl,
%     \l_@@_par_itemstart_nostar_tl,
%     \l_@@_par_itemstart_star_tl,
%     \l_@@_par_itemstart__tl,
%     \l_@@_par_start_nostar_tl,
%     \l_@@_par_start_star_tl,
%     \l_@@_par_start__tl,
%     \l_@@_sentence_end_nostar_tl,
%     \l_@@_sentence_end_star_tl,
%     \l_@@_sentence_end__tl,
%     \l_@@_sentence_itemend_nostar_tl,
%     \l_@@_sentence_itemend_star_tl,
%     \l_@@_sentence_itemend__tl,
%     \l_@@_sentence_itemseparator_nostar_tl,
%     \l_@@_sentence_itemseparator_star_tl,
%     \l_@@_sentence_itemseparator__tl,
%     \l_@@_sentence_itemstart_nostar_tl,
%     \l_@@_sentence_itemstart_star_tl,
%     \l_@@_sentence_itemstart__tl,
%     \l_@@_sentence_start_nostar_tl,
%     \l_@@_sentence_start_star_tl,
%     \l_@@_sentence_start__tl,
%   }
%   These variables store the separators and delimiters added around the
%   paragraphs and sentences, in the starred or nonstarred variants, as
%   well as the generic version for runtime usage.
%    \begin{macrocode}
\clist_map_inline:nn { start, itemstart, itemseparator, itemend, end }
  {
    \clist_map_inline:nn { par, sentence }
      {
        \clist_map_inline:nn { { }, star, nostar }
          { \tl_new:c { l_@@_##1_#1_####1_tl } }
      }
    \tl_new:c { l_@@_par_#1_parsepar_tl }
  }
\tl_set:Nn \l_@@_par_itemseparator_parsepar_tl { ~ }
%    \end{macrocode}
% \end{variable}
%
% \subsection{Developer interface}
%
% \begin{macro}{\@@_parse_par_range:nNN,\@@_parse_par_range:eNN}
% \begin{macro}{\@@_parse_sentence_range:nNN,\@@_parse_sentence_range:eNN}
% \begin{macro}{\@@_parse_range_arg:nNNn,\@@_parse_range_arg:wnNNn}
% \begin{macro}{\@@_int_set:Nnn}
%   Parses an argument that may be a single integer or an integer range
%   separated by a |-|, and stores them into the integer registers |#2|
%   and |#3|.  If a number is blank, zero is used.  If only a single
%   number is given, |#3| is set equal to |#2|.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_par_range:nNN #1 #2 #3
  {
    \tl_if_blank:nTF {#1}
      { \exp_args:NV \@@_parse_range_arg:nNNn \g_redrum_default_range_tl }
      { \@@_parse_range_arg:nNNn {#1} }
          #2 #3 { \g_@@_par_int }
  }
\cs_new_protected:Npn \@@_parse_sentence_range:nNN #1 #2 #3
  { \@@_parse_range_arg:nNNn {#1} #2 #3 { \c_max_int } }
\cs_new_protected:Npn \@@_parse_range_arg:nNNn #1
  {
    \exp_last_unbraced:No \@@_parse_range_arg:wnNNn
      \tl_to_str:n { #1 - - } \s_@@ {#1}
  }
\cs_new_protected:Npn \@@_parse_range_arg:wnNNn
    #1 - #2 - #3 \s_@@ #4 #5#6 #7
  {
    \str_if_eq:nnTF {#3} { - }
      {
        \@@_int_set:Nnn #5 {#1} { 1 }
        \@@_int_set:Nnn #6 {#2} {#7}
      }
      {
        \tl_if_empty:nTF {#3}
          {
            \@@_int_set:Nnn #5 {#1} { \ERROR }
            \int_set_eq:NN #6 #5
          }
          {
            \msg_error:nnn { redrum } { invalid-range } {#4}
            \@@_parse_range_arg:nNNn { 2 - 1 } #5 #6 {#7}
          }
      }
  }
\cs_new_protected:Npn \@@_int_set:Nnn #1 #2 #3
  { \int_set:Nn #1 { \tl_if_blank:nT {#2} {#3} #2 } }
\cs_generate_variant:Nn \@@_parse_par_range:nNN { e }
\cs_generate_variant:Nn \@@_parse_sentence_range:nNN { e }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_sep_item:nn}
%   A shorthand to leave an (\cs{undexpanded}) token list.
%    \begin{macrocode}
\cs_new:Npn \@@_sep_item:nn #1 #2
  { \exp_not:v { l_@@_#1_#2_ \l_@@_sep_set_str _tl } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\redrum_get_range:nn}
% \begin{macro}{
%     \@@_build_list:nn,
%     \@@_build_list_aux:n,
%     \@@_get_paragraph:ww,
%     \@@_get_paragraph_end:w,
%   }
%   Expands to the paragraphs between \meta{number_1} and
%   \meta{number_2} with the proper delimiters added.  Text is returned
%   in \cs{exp_not:n}, so this macro can be safely used in an \cs{edef}.
%    \begin{macrocode}
\cs_new:Npn \redrum_get_range:nn #1 #2
  {
    \@@_sep_item:nn { par } { start }
    \use:e
      {
        \exp_not:N \@@_get_paragraph:ww
        \@@_build_list:nn {#1} {#2}
        \exp_not:N \q_@@_mark ;
        \exp_not:N \q_@@_mark ; \s_@@
      }
    \@@_sep_item:nn { par } { end }
  }
\cs_new:Npn \@@_build_list:nn #1 #2
  {
    \int_step_function:nnN
      { \int_max:nn {#1} { 1 } }
      { \int_min:nn {#2} { \g_@@_par_int } }
      \@@_build_list_aux:n
  }
\cs_new:Npn \@@_build_list_aux:n #1 { #1 ; }
\cs_new:Npn \@@_get_paragraph:ww #1 ; #2 ;
  {
    \if_meaning:w \q_@@_mark #2
      \if_meaning:w \q_@@_mark #1
        \@@_get_paragraph_end:w
      \else:
        \redrum_get_paragraph:n {#1}
      \fi:
    \else:
      \redrum_get_paragraph:n {#1}
      \@@_sep_item:nn { par } { itemseparator }
    \fi:
    \@@_get_paragraph:ww #2 ;
  }
\cs_new:Npn \@@_get_paragraph_end:w #1 \s_@@ { \fi: \fi: }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\redrum_get_paragraph:n}
%   Expands to the paragraph \meta{number} with the proper delimiters
%   added.  Text is returned in \cs{exp_not:n}, so this macro can be
%   safely used in an \cs{edef}.
%    \begin{macrocode}
\cs_new:Npn \redrum_get_paragraph:n #1
  {
    \@@_sep_item:nn { par } { itemstart }
    \@@_unexpanded_par:n {#1}
    \@@_sep_item:nn { par } { itemend }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_unexpanded_par:n}
%   Expands to the paragraph \meta{number} wrapped in \cs{exp_not:n}.
%   If \meta{number} is out of range, it expands to nothing.
%    \begin{macrocode}
\cs_new:Npn \@@_unexpanded_par:n #1
  {
    \bool_lazy_and:nnT
        { \int_compare_p:nNn { 0 } < {#1} }
        { \int_compare_p:nNn {#1}  < { \g_@@_par_int + 1 } }
      { \exp_not:v { g_@@_par_#1_tl } }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\redrum_get_sentences:nnn,\redrum_get_sentences:nnV}
% \begin{macro}{\@@_get_sentences:nnnw,\@@_get_sentences_end:w}
%   Expands to the sentences numbered between \meta{number_1} and
%   \meta{number_2}, inclusive, contained in the \meta{text}, and adding
%   the proper separators.
%    \begin{macrocode}
\cs_new:Npn \redrum_get_sentences:nnn #1 #2 #3
  {
    \@@_sep_item:nn { sentence } { start }
    \exp_args:Ne \use_ii_i:nn { { \int_max:nn {#1} { 1 } } }
      { \@@_get_sentences:nnnw { 1 } } {#2}
      #3 ~ \q_@@_mark .~ \s_@@
    \@@_sep_item:nn { sentence } { end }
  }
\cs_new:Npn \@@_get_sentences:nnnw #1 #2 #3 #4 .~
  {
    \int_compare:nNnT {#1} > {#3} { \@@_get_sentences_end:w }
    \use:nn { \if_meaning:w \q_@@_mark } #4
      \exp_after:wN \@@_get_sentences_end:w
    \else:
      \int_compare:nNnF {#1} < {#2}
        {
          \int_compare:nNnF {#1} = {#2}
            { \@@_sep_item:nn { sentence } { itemseparator } }
          \@@_sep_item:nn { sentence } { itemstart }
          \exp_not:n { #4 . }
          \@@_sep_item:nn { sentence } { itemend }
        }
    \fi:
    \exp_args:Nf \@@_get_sentences:nnnw { \int_eval:n { #1 + 1 } }
      {#2} {#3}
  }
\cs_new:Npn \@@_get_sentences_end:w #1 \s_@@ { }
\cs_generate_variant:Nn \redrum_get_sentences:nnn { nnV }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{User- and developer-level commands}
%
% \begin{macro}[int]{\RedrumPar}
%   Macro to typeset a single paragraph of \redr
%   \begin{arguments}
%     \item Number of the paragraph to typeset.
%   \end{arguments}
% Implemented as follows:
%    \begin{macrocode}
\NewDocumentCommand \RedrumPar { m }
  {
    \@@_deprecated:n { RedrumPar }
    \@@_unexpanded_par:n {#1} \par
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Tokens surrounding the \redr\ content}
%
% \begin{macro}{\@@_element_set:nnn}
%   A general macro for setting starred/non-starred versions of several
%   elements used between chunks of dummy text. Arguments are:
%   \begin{arguments}
%     \item Element name;
%     \item Boolean true or false if the |*| variant was used;
%     \item Value to set the element to.
%   \end{arguments}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_element_set:nnn #1 #2 #3
  { \tl_set:cn { l_@@_ #1 _ \IfBooleanF {#2} { no } star _tl } {#3} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_deprecated:n}
%   Warns about deprecated commands and destroys itself.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_deprecated:n #1
  {
    \msg_warning:nnn { redrum } { cmd-deprecated } {#1}
    \cs_gset_eq:NN \@@_deprecated:n \use_none:n
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{
%     \SetRedrumParListStart,
%     \SetRedrumParListEnd,
%     \SetRedrumParListSurrounders,
%     \SetRedrumParListItemSeparator,
%     \SetRedrumParListItemStart,
%     \SetRedrumParListItemEnd,
%     \SetRedrumParListItemSurrounders,
%     \SetRedrumSentenceListStart,
%     \SetRedrumSentenceListEnd,
%     \SetRedrumSentenceListSurrounders,
%     \SetRedrumSentenceListItemSeparator,
%     \SetRedrumSentenceListItemStart,
%     \SetRedrumSentenceListItemEnd,
%     \SetRedrumSentenceListItemSurrounders,
%   }
%   A dirty loop to quickly define the old command-based user-interface.
%    \begin{macrocode}
\cs_set_protected:Npn \@@_tmp:w #1 #2 #3 #4
  {
    \str_set:Nx \l_@@_tmpa_str
      { #2 \tl_if_empty:nTF {#4} {#3} { start } }
    \use:e
      {
        \NewDocumentCommand \exp_not:c { SetRedrum #1 List #2 #3 }
            { s +m \tl_if_empty:nF {#4} { +m } }
          {
            \@@_deprecated:n { SetRedrum #1 List #2 #3 }
            \@@_element_set:nnn
              { \exp_args:Ne \str_lowercase:n { #1_\l_@@_tmpa_str } }
              {##1} {##2}
            \tl_if_empty:nT {#4} { \use_none:nnnn }
            \@@_element_set:nnn { \str_lowercase:n { #1_#2 #4 } }
              {##1} {##3}
          }
      }
  }
\clist_map_inline:nn { Par, Sentence }
  {
    \clist_map_inline:nn
      { { Start } { }, { End } { }, { Surrounders } { end } }
      { \@@_tmp:w {#1} { Item } ##1 \@@_tmp:w {#1} { } ##1 }
    \@@_tmp:w {#1} { Item } { Separator } { }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SetRedrumDefault}
%   Command to change the default range used by \cs{redrum} and friends.
%   \begin{arguments}
%     \item[\meta{range}] Range to be used as default.
%   \end{arguments}
% Implemented as:
%    \begin{macrocode}
\NewDocumentCommand \SetRedrumDefault { m }
  {
    \@@_parse_par_range:eNN {#1} \l_@@_a_int \l_@@_b_int
    \tl_gset:Nx \g_redrum_default_range_tl
      { \int_use:N \l_@@_a_int - \int_use:N \l_@@_b_int }
  }
%    \end{macrocode}
% \end{macro}
%
% The following macros are considered to be user-level commands and thus
% all lower-case.
%
% \begin{macro}{\redrum}
%   \begin{arguments}
%     \item Range-like string that specifies the number of the
%       paragraphs taken from \redr\ If omitted, the value set by
%       \cs{SetRedrumDefault} is used, which defaults to |1-7|.
%     \item Sentences to be typeset from the range selected by
%       \meta{paragraph range}. If sentences outside the number of
%       sentences in \meta{paragraph range} are specified, only existing
%       sentences are typeset.
%   \end{arguments}
%   The difference between \cs{redrum} and \cs{redrum*} is the token(s)
%   that are inserted after each paragraph (only if called without the
%   second optional argument).
%
%   \cs{redrum} and \cs{unpackredrum} have the same interface and do
%   almost the same thing, so both are implemented using a common macro
%   \cs{@@_do:nnnn} that does the heavy-lifting, and at the end
%   executes the code in |#4|.
%    \begin{macrocode}
\NewDocumentCommand \redrum { s O { \g_redrum_default_range_tl } o }
  {
    \@@_do:nnnn {#1} {#2} {#3}
      {
        \@@_set_hyphens:
        \tl_use:N ##1
        \@@_restore_hyphens:
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\unpackredrum,\redrumexp}
%   This command does the same as \cs{redrum}, but instead of
%   typesetting the paragraphs or sentences, it stores the expanded
%   content in the \cs{redrumexp} token list. The tokens between items
%   of the list, set, for example, by using the package option
%   \opt{space} or by using the \cs{SetRedrum...List} commands, are
%   |x|-expanded.
%    \begin{macrocode}
\NewDocumentCommand \unpackredrum { s O { \g_redrum_default_range_tl } o }
  { \@@_do:nnnn {#1} {#2} {#3} { \tl_gset_eq:NN \redrumexp ##1 } }
\cs_new_eq:NN \redrumexp \prg_do_nothing:
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_do:nnnn}
% \begin{macro}{\@@_do:N}
%   This is the main macro for \cs{redrum} and \cs{unpackredrum}.
%   It parses the paragraph range, sets the sentence/paragraph
%   separators, then acts accordingly if a sentence range was provided.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_do:nnnn #1 #2 #3 #4
  {
    \cs_set_protected:Npn \@@_do:N ##1 {#4}
    \@@_parse_par_range:eNN {#2} \l_@@_a_int \l_@@_b_int
    \str_set_eq:NN \l_@@_tmpa_str \l_@@_sep_set_str
    \str_set:Nx \l_@@_sep_set_str { \IfBooleanF {#1} { no } star }
    \bool_lazy_or:nnTF
        { \tl_if_novalue_p:n {#3} }
        { \tl_if_blank_p:n {#3} }
      {
        \tl_set:Nx \l_@@_output_tl
          { \redrum_get_range:nn { \l_@@_a_int } { \l_@@_b_int } }
      }
      {
        \str_set:Nn \l_@@_sep_set_str { parsepar }
        \tl_set:Nx \l_@@_output_tl
          { \redrum_get_range:nn { \l_@@_a_int } { \l_@@_b_int } }
        \str_set:Nx \l_@@_sep_set_str { \IfBooleanF {#1} { no } star }
        \@@_parse_sentence_range:eNN {#3} \l_@@_a_int \l_@@_b_int
        \tl_set:Nx \l_@@_output_tl
          {
            \redrum_get_sentences:nnV { \l_@@_a_int } { \l_@@_b_int }
              \l_@@_output_tl
          }
      }
    \str_set_eq:NN \l_@@_sep_set_str \l_@@_tmpa_str
    \@@_do:N \l_@@_output_tl
  }
\cs_new_eq:NN \@@_do:N ?
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_set_hyphens:,\@@_restore_hyphens:}
%   Selects the hyphenation patterns for the language of the dummy text,
%   using \cs{hyphenrules} if that's defined.  If \cs{hyphenrules}
%   doesn't exist try setting hyphenation with \cs{@@_set_hyphens_raw:}.
%   Each \cs[no-index]{@@_set_hyphens_\meta{method}:} function
%   appropriately redefines \cs{@@_restore_hypehens:} to reset the
%   hyphenation patterns.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_set_hyphens:
  {
    \bool_if:NTF \l_@@_autolang_bool
      { \use:n } { \use_none:n }
      {
        \cs_if_exist:NTF \hyphenrules
          {
            \cs_if_exist:cTF { ver@polyglossia.sty }
              { \@@_set_hyphens_polyglossia: }
              { \@@_set_hyphens_babel: }
          }
          { \@@_set_hyphens_raw: }
      }
  }
\cs_new_protected:Npn \@@_restore_hyphens:
  { \prg_do_nothing: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_set_hyphens_babel:}
%   \pkg{babel} makes things pretty simple.  We just check if
%   \cs[no-index]{l@\meta{lang}} is defined, and if so, use
%   \cs{hyphenrules} to set it, and once more to reset in
%   \cs{@@_restore_hyphens:}.  \cs{hyphenrules} is actually an
%   environment, but in \pkg{babel} its \cs[no-index]{end} part does
%   nothing, and its effect can be undone by just using another
%   \cs{hyphenrules} on top of it.
%
%   If the language is not defined, the language either doesn't exist at
%   all, or we are using Lua\TeX.  Both cases are handled by
%   \cs{@@_lang_not_available:}.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_set_hyphens_babel:
  {
    \cs_if_exist:cTF { l@ \g_@@_language_tl }
      {
        \exp_args:NV \hyphenrules \g_@@_language_tl
        \cs_set_protected:Npx \@@_restore_hyphens:
          { \exp_not:N \hyphenrules { \languagename } }
      }
      { \@@_lang_not_available: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_set_hyphens_polyglossia:}
%   \pkg{polyglossia} less friendly.  We also check if the language is
%   loaded (looking at \cs[no-index]{\meta{lang}@loaded}), and if it
%   is, load it with the \env{hyphenrules} environment.  Here we can't
%   use the command form, as the \cs[no-index]{end} part is not a no-op.
%   This also means that an extra group is added around the dummy text,
%   which causes issue \ghissue{1} when used with \pkg{wrapfig}, for
%   example.  But not too much we can do about that for now.
%
%   In case the language is not loaded, fall back to
%   \cs{@@_set_hyphens_raw:} for a final attempt before giving up.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_set_hyphens_polyglossia:
  {
    \cs_if_exist:cTF { \g_@@_language_tl @loaded }
      {
        \exp_args:NnV \begin{hyphenrules} \g_@@_language_tl
        \cs_set_protected:Npn \@@_restore_hyphens:
          { \end{hyphenrules} }
      }
      { \@@_set_hyphens_raw: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_set_hyphens_raw:}
%   If nothing else is available, try setting the language using
%   \cs{language}\meta{number}.  This is always available,
%   except with Lua\TeX, which loads languages on-the-fly.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_set_hyphens_raw:
  {
    \cs_if_exist:cTF { l@ \g_@@_language_tl }
      {
        \use:x
          {
            \language \use:c { l@ \g_@@_language_tl }
            \cs_set_protected:Npn \@@_restore_hyphens:
              { \language \int_eval:n { \language } \scan_stop: }
          }
      }
      { \@@_lang_not_available: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_lang_not_available:}
%   If the requested language is for some reason unavailable, warn the
%   user, then fall back to the current language.  If the requested
%   language and \cs{languagename} are the same, we are probably running
%   into this warning again because we have no languages loaded (e.g.,
%   testing environments).  In that case, shut up because there's not
%   much that can be done (and a warning that says ``language "english"
%   is not available; using "english" instead'' is of little use).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_lang_not_available:
  {
    \str_if_eq:VVF \g__redrum_language_tl \languagename
      {
        \msg_warning:nnx { redrum } { missing-language }
          { \g_@@_language_tl }
        \tl_gset_eq:NN \g_@@_language_tl \languagename
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\NewRedrumPar}
%   Developer-Level macro to add a paragraph to the dummy text used by
%   \cs{redrum} and related commands. To specify a new dummy text, see
%   section~\ref{sec:other-texts}.
%    \begin{macrocode}
\cs_new_protected:Npn \NewRedrumPar #1
  {
    \int_gincr:N \g_@@_par_int
    \tl_gclear_new:c { g_@@_par_ \int_use:N \g_@@_par_int _tl }
    \tl_gset:cn { g_@@_par_ \int_use:N \g_@@_par_int _tl } {#1}
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SetRedrumText}
%   Used to select and load the text output by \cs{redrum} and friends.
%   See the section on loading and defining new outputs for \cs{redrum}
%   (section~\ref{sec:other-texts}). It first checks whether the
%   requested text is already loaded, and if not, it loads the
%   corresponding redrum text definition file, and clears remaining
%   paragraphs from the previous text, in case their lengths differ.
%    \begin{macrocode}
\NewDocumentCommand \SetRedrumText { m }
  {
    \str_if_eq:VnF \g_@@_text_str {#1}
      {
        \tl_gset:Nn \g_@@_language_tl { english }
        \int_gzero:N \g_@@_par_int
        \file_input:n { #1.ltd }
        \str_gset:Nn \g_@@_text_str {#1}
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\SetRedrumLanguage}
%   This macro sets the language for hyphenation patterns of the dummy
%   text.  When a new redrum text is read, this is reset.
%    \begin{macrocode}
\NewDocumentCommand \SetRedrumLanguage { m }
  { \tl_gset:Nn \g_@@_language_tl {#1} }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Package options and defaults}
%
% \begin{macro}[int]{
%     \RedrumRestoreParList,
%     \RedrumRestoreSentenceList,
%     \RedrumRestoreAll,
%   }
% \begin{macro}{\@@_delim_restore:nnn}
% \begin{macro}{\@@_restore_par_list:,\@@_restore_sentence_list:}
%   These are some auxiliaries for the package options and for setting
%   up the default behaviour.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_delim_restore:nnn #1 #2 #3
  {
    \keys_set:nn { redrum }
      {
        #1-before  = , #1-begin  = , #1-end  = , #1-after  = ,
        #1-before* = , #1-begin* = , #1-end* = , #1-after* = ,
        #1-sep = {#2}, #1-sep* = {#3}
      }
  }
\cs_new_protected:Nn \@@_restore_sentence_list:
  { \@@_delim_restore:nnn { sentence } { ~ } { ~ } }
\cs_new_eq:NN \@@_restore_par_list: ?
\cs_new_protected:Npn \RedrumRestoreParList
  {
    \@@_deprecated:n { RedrumRestoreParList }
    \@@_restore_par_list:
  }
\cs_new_protected:Npn \RedrumRestoreSentenceList
  {
    \@@_deprecated:n { RedrumRestoreSentenceList }
    \@@_restore_sentence_list:
  }
\cs_new_protected:Npn \RedrumRestoreAll
  {
    \@@_deprecated:n { RedrumRestoreAll }
    \@@_restore_par_list: \@@_restore_sentence_list:
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\setredrum}
%   Here are the options available at load-time and to \cs{setredrum}.
%    \begin{macrocode}
\NewDocumentCommand \setredrum { +m }
  { \keys_set:nn { redrum } {#1} }
\keys_define:nn { redrum }
  {
%    \end{macrocode}
%   \opt{nopar} is implemented as a choice key instead of a boolean so
%   we can update the separators using \cs{@@_delim_restore:nnn}.
%   It's initially false, and the default is |true| so that
%   |\usepackage[nopar]{redrum}| works as it always did.
%    \begin{macrocode}
    nopar .choice: ,
    nopar / true .code:n =
      {
        \cs_gset_protected:Npn \@@_restore_par_list:
          { \@@_delim_restore:nnn { par } { ~ } { \par } }
      } ,
    nopar / false .code:n =
      {
        \cs_gset_protected:Nn \@@_restore_par_list:
          { \@@_delim_restore:nnn { par } { \par } { ~ } }
      } ,
    nopar .initial:n = false ,
    nopar .default:n = true  ,
%    \end{macrocode}
%   \opt{auto-lang} sets \cs{l_@@_autolang_bool}.  It is initially
%   |true|.
%    \begin{macrocode}
    auto-lang .bool_set:N = \l_@@_autolang_bool ,
    auto-lang .initial:n = true ,
    auto-lang .default:n = true ,
%    \end{macrocode}
%   \opt{text} just does \cs{SetRedrumText}.  The |initial| value is not
%   set here because this chunk of code is executed in \pkg{expl3}
%   syntax, then thetextloadswithoutspaces, so |\setredrum{text=redrum}|
%   is used later.
%    \begin{macrocode}
    text .code:n = \SetRedrumText{#1} ,
    text .value_required:n = true ,
%    \end{macrocode}
%   \opt{language} sets the language to be used when typesetting.
%    \begin{macrocode}
    language .tl_gset:N = \g_@@_language_tl ,
    language .value_required:n = true ,
%    \end{macrocode}
%   \opt{default-range} does \cs{SetRedrumDefault}, initially |1-7|, as
%   documented.  It's default is also |1-7| so that the key has two
%   meanings: \cs{setredrum}|{default-range=|\meta{range}|}| sets the
%   range to the given value, while \cs{setredrum}|{default-range}| sets
%   the range to the ``default default range''.  Pretty neat :)
%    \begin{macrocode}
    default-range .code:n = \SetRedrumDefault{#1} ,
    default-range .initial:n = 1-7 ,
    default-range .default:n = 1-7 ,
  }
%    \end{macrocode}
%   This chunk defines the keys \meta{thing}-\meta{place}[*], where
%   \meta{thing} is |par| or |sentence|, \meta{place} is |before|,
%   |begin|, |sep|, |end|, and |after|, which totals~10 keys, and
%   another~10 with the |*| in the name.  Each sets a token list called
%   \cs[no-index]{l_@@_\meta{thing}_\meta{place}_[no]star_tl}.
%    \begin{macrocode}
\cs_set_protected:Npn \@@_tmp:w #1 #2 #3
  {
    \keys_define:nn { redrum }
      {
        #1-before #2 .tl_set:c = l_@@_#1_start         _#3star_tl ,
        #1-begin  #2 .tl_set:c = l_@@_#1_itemstart     _#3star_tl ,
        #1-sep    #2 .tl_set:c = l_@@_#1_itemseparator _#3star_tl ,
        #1-end    #2 .tl_set:c = l_@@_#1_itemend       _#3star_tl ,
        #1-after  #2 .tl_set:c = l_@@_#1_end           _#3star_tl ,
      }
  }
\@@_tmp:w { par } { } { no } \@@_tmp:w { sentence } { } { no }
\@@_tmp:w { par }  *  {    } \@@_tmp:w { sentence }  *  {    }
%    \end{macrocode}
% \end{macro}
%
% Now turn \cs{ExplSyntaxOff} for a while, and load the default \redr{}
% text, then process the package options, and finally turn
% \cs{ExplSyntaxOn} again.  Finally, call \cs{@@_restore_par_list:} and
% \cs{@@_restore_sentence_list:} to set the defaults
% (\cs{@@_restore_par_list:} may have been redefined by \opt{nopar}).
%    \begin{macrocode}
\ExplSyntaxOff
\setredrum{text=redrum}
\ProcessKeysOptions{redrum}
\ExplSyntaxOn
\@@_restore_par_list:
\@@_restore_sentence_list:
%    \end{macrocode}
%
% \subsection{Messages}
%
% Now define the messages used throughout the package.
%    \begin{macrocode}
\msg_new:nnn { redrum } { invalid-range }
  { Invalid~number~or~range~'#1'. }
\msg_new:nnn { redrum } { cmd-deprecated }
  {
    Command~'\iow_char:N\\#1'~deprecated. \\
    See~the~redrum~documentation~for~help.
  }
\msg_new:nnn { redrum } { missing-language }
  {
    Unknown~language~'#1'.~Hyphenation~patterns~for~
    '\languagename'~will~be~used~instead.
    \sys_if_engine_luatex:T
      {
        \\ \\
        \cs_if_exist:cTF { ver@polyglossia.sty }
          {
            With~polyglossia,~you~have~to~explicitly~load~languages~
            with~\iow_char:N\\setotherlanguage{#1}~or~similar.
          }
          {
            With~LuaTeX,~redrum~requires~babel~to~get~proper~
            hyphenation~(you~can~use~
            \iow_char:N\\usepackage[base]{babel}).
          }
      }
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \endinput
% Local Variables:
% mode: doctex
% TeX-master: t
% End:
